#!/usr/bin/python

# Generates timing graphs of a function and outputs them to an image file.

import argparse
import commands
import glob
import math
import os
import sys

import matplotlib.pyplot as plt
import numpy as np

import comb

def strs(string):
    """
    Split comma-separated `string` into `str`s.
    """
    return string.split(',')

def ints(string):
    """
    Split a comma-separated `string` into `int`s.
    """
    return map(int, strs(string))

def makedirs(dirs):
    """
    Create `dirs` if they don't exist.
    """
    try:
        os.makedirs(dirs)
    except OSError:
        if not os.path.isdir(dirs):
            raise

def glob_match(pttn):
    """
    Return the filename components matching a wildcard `pttn`.

    For example, in a directory containing `a.c`, `b.c` and `c.c`,
    glob_match('*.c') will return ['a', 'b', 'c'].
    """
    if pttn.count('*') != 1:
        raise ValueError("`pttn` must contain exactly one wildcard")
    start = pttn.index('*')
    end = len(pttn) - start - 1
    return map(lambda name: name[start:-end], glob.glob(pttn))

def run(cmd):
    """
    Execute `cmd` on the command-line.

    `run()` executes in a fashion similar to the `make` tool: it prints the
    command that is to be run, executes it, and if quits with the command's
    output if the return code is non-zero.
    """
    print cmd
    exit_code, output = commands.getstatusoutput(cmd)
    if exit_code != 0:
        sys.exit(output)

# Order of these options matters because they are in the order they occur in
# the output files generated by our `Makefile`. Ideally the filename pattern
# would be extracted and parsed when this script is run, but this process will
# be omitted due to time constraints on the project.
fields = ['funcs', 'cc', 'opt', 'size']

parser = argparse.ArgumentParser(description='Plot the timing of a function')
parser.add_argument('-f', '--funcs', type=strs, default=glob_match("src/time_*.c"), help="matrix function to time")
parser.add_argument('-c', '--cc', type=strs, default=['cc'], help="C compiler")
parser.add_argument('-o', '--opt', type=ints, default=[0], help="C compiler optimization")
parser.add_argument('-n', '--num_points', type=int, default=10, help="number of graph points")
parser.add_argument('-s', '--size', type=ints, default=[100], help="matrix width and height")

args = vars(parser.parse_args())

makedirs("build/fig")

impls = glob_match("src/matrix_*.c")

make_fmt = lambda pairs: ' '.join("%s=%s" % pair for pair in pairs)

fig = plt.figure()
fig.suptitle("Timing of " +
    make_fmt((f.upper(), args[f][0]) for f in fields if len(args[f]) == 1),
    fontweight='bold')
fig.text(0.03, 0.5, 'Time (ns)', ha='center', va='center', rotation='vertical')
fig.text(0.5, 0.06, 'Density (%)', ha='center', va='center')

# FIXME `css` is a list of `(f, v)` pairs, where `f` is a field name and `v` is
# the possible values for the field. The list is sorted in descending order on
# the size of `v`, which makes some graphs look nicer (graphs where the number
# of columns is equal to the size of the largest `v`). This is a very hacky
# implementation and should be replaced as soon as it is feasible.
css = sorted([(f, args[f]) for f in fields], key=lambda p: len(p[1]), reverse=True)

cs = list(comb.combs(map(lambda x: x[1], css)))
y = int(math.ceil(math.sqrt(len(cs)+1)))
x = int(math.ceil((len(cs)+1) / float(y)))
ax = None
for i in xrange(len(cs)):
    ax = fig.add_subplot(x, y, 1+i, sharex=ax, sharey=ax)
    c = dict(zip(map(lambda f: f[0], css), map(str, cs[i])))
    fname = ("build/dat/time_" + c['funcs'] +
             "_%s_" + '_'.join(c[f] for f in fields if f != 'funcs') + '_'
             + str(args['num_points']) + '.txt')
    ax.set_title(
        make_fmt((f.upper(), c[f]) for f in fields if len(args[f]) != 1),
        fontsize=10)

    for impl in impls:
        env_vars = [('IMPL', impl)] + [(f.upper(), c[f]) for f in fields] + [('NUM_POINTS', args['num_points'])]
        run("%s make %s" % (' '.join("%s=%s" % v for v in env_vars), fname % impl))

        with open(fname % impl) as f:
            size, points = map(int, f.readline().split(' '))
            xs = range(0, size**2, (size**2)/points)
            ys = [float(f.readline()[:-1]) for _ in xrange(points)]

            # FIXME again, this is a hacky solution to the problem that
            # sometimes the sizes of `xs` and `ys` are out of sync and should
            # be fixed as soon as the time becomes available.
            ax.plot(xs[:args['num_points']], ys[:args['num_points']], label=impl)

            for pos in ['top', 'right']:
                ax.spines[pos].set_color('none')

            start, end = ax.get_xlim()
            ax.set_xticks(np.arange(start, end, (end-start)/4))
            ax.set_xticklabels([])
            ax.get_xaxis().tick_bottom()

            if i % y != 0:
                plt.setp(ax.get_yticklabels([]), visible=False)
            ax.get_yaxis().tick_left()

ax = fig.add_subplot(x, y, x*y)
for impl in impls:
    ax.plot([], [], label=impl)
ax.legend()
ax.set_axis_off()

outf = "build/fig/time_" + '_'.join(','.join(map(str, args[name])) for name in fields) + ".jpg"
print "Writing %s..." % outf
fig.savefig(outf)
