#!/usr/bin/python

# Generates timing graphs of a function and outputs them to an image file.

import argparse
import commands
import glob
import math
import os

import matplotlib.pyplot as plt
import numpy as np

import comb

def strs(string):
    """
    Split comma-separated `string` into `str`s.
    """
    return string.split(',')

def ints(string):
    """
    Split a comma-separated `string` into `int`s.
    """
    return map(int, strs(string))

def makedirs(dirs):
    """
    Create `dirs` if they don't exist.
    """
    try:
        os.makedirs(dirs)
    except OSError:
        if not os.path.isdir(dirs):
            raise

def glob_match(pttn):
    """
    Return the filename components matching a wildcard `pttn`.

    For example, in a directory containing `a.c`, `b.c` and `c.c`,
    glob_match('*.c') will return ['a', 'b', 'c'].
    """
    if pttn.count('*') != 1:
        raise ValueError("`pttn` must contain exactly one wildcard")
    start = pttn.index('*')
    end = len(pttn) - start - 1
    return map(lambda name: name[start:-end], glob.glob(pttn))

def run(cmd):
    """
    Execute `cmd` on the command-line.

    `run()` executes in a fashion similar to the `make` tool: it prints the
    command that is to be run, executes it, and if quits with the command's
    output if the return code is non-zero.
    """
    print cmd
    exit_code, output = commands.getstatusoutput(cmd)
    if exit_code != 0:
        print output
        exit(1)

# Order of these options matters because they are in the order they occur in
# the output files generated by our `Makefile`. Ideally the filename pattern
# would be extracted and parsed when this script is run, but this process will
# be omitted due to time constraints on the project.
fields = ['cc', 'opt', 'size']

parser = argparse.ArgumentParser(description='Plot the timing of a function')
parser.add_argument('func', help="matrix function to time")
parser.add_argument('-c', '--cc', type=strs, default=['cc'], help="C compiler")
parser.add_argument('-o', '--opt', type=ints, default=[0], help="C compiler optimization")
parser.add_argument('-n', '--num_points', type=int, default=1000, help="number of graph points")
parser.add_argument('-s', '--size', type=ints, default=[512], help="matrix width and height")

args = vars(parser.parse_args())

makedirs("build/fig")

impls = glob_match("src/matrix_*.c")

make_fmt = lambda pairs: ' '.join("%s=%s" % pair for pair in pairs)

fig = plt.figure()
fig.suptitle("Timing of {0}, ".format(args['func']) +
    make_fmt((f.upper(), args[f][0]) for f in fields if len(args[f]) == 1),
    fontweight='bold')
fig.text(0.03, 0.5, 'Time (ms)', ha='center', va='center', rotation='vertical')
fig.text(0.5, 0.06, 'Density (%)', ha='center', va='center')
cs = list(comb.combs([args[f] for f in fields]))
y = int(math.ceil(math.sqrt(len(cs)+1)))
x = int(math.ceil((len(cs)+1) / float(y)))
ax = None
for i in xrange(len(cs)):
    ax = fig.add_subplot(x, y, 1+i, sharex=ax, sharey=ax)
    c = dict(zip(fields, map(str, cs[i])))
    fname = ("build/dat/time_" + args['func'] +
             "_%s_" + '_'.join(c[f] for f in fields) + '_'
             + str(args['num_points']) + '.txt')
    ax.set_title(
        make_fmt((f.upper(), c[f]) for f in fields if len(args[f]) != 1),
        fontsize=10)

    for impl in impls:
        env_vars = [('IMPL', impl)] + [(f.upper(), c[f]) for f in fields] + [('NUM_POINTS', args['num_points'])]
        run("%s make %s" % (' '.join("%s=%s" % v for v in env_vars), fname % impl))

        with open(fname % impl) as f:
            size, points = map(int, f.readline().split(' '))
            xs = range(0, size**2, (size**2)/points)
            ys = [float(f.readline()[:-1]) for _ in xrange(points)]
            if len(xs) != len(ys): # FIXME find out why xs is too big sometimes
                xs = xs[:-1]

            ax.plot(xs, ys, label=impl)

            for pos in ['top', 'right']:
                ax.spines[pos].set_color('none')

            start, end = ax.get_xlim()
            ax.set_xticks(np.arange(start, end, (end-start)/4))
            ax.set_xticklabels([])
            ax.get_xaxis().tick_bottom()

            if i % y != 0:
                plt.setp(ax.get_yticklabels([]), visible=False)
            ax.get_yaxis().tick_left()

ax = fig.add_subplot(x, y, x*y)
for impl in impls:
    ax.plot([], [], label=impl)
ax.legend()
ax.set_axis_off()

outf = "build/fig/time_" + '_'.join(','.join(map(str, args[name])) for name in fields) + ".jpg"
print "Writing %s..." % outf
fig.savefig(outf)
