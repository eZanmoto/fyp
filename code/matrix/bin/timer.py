#!/usr/bin/python

# Aggregates timings of functions into a file of the format described in
# `doc/plot_format.md`

import argparse
import commands
import json
import glob
import sys

import comb

def strs(string):
    """
    Split comma-separated `string` into `str`s.
    """
    return string.split(',')

def ints(string):
    """
    Split a comma-separated `string` into `int`s.
    """
    return map(int, strs(string))

def glob_match(pttn):
    """
    Return the filename components matching a wildcard `pttn`.

    For example, in a directory containing `a.c`, `b.c` and `c.c`,
    glob_match('*.c') will return ['a', 'b', 'c'].
    """
    if pttn.count('*') != 1:
        raise ValueError("`pttn` must contain exactly one wildcard")
    start = pttn.index('*')
    end = len(pttn) - start - 1
    return map(lambda name: name[start:-end], glob.glob(pttn))

def run(cmd):
    """
    Execute `cmd` on the command-line.

    `run()` executes in a fashion similar to the `make` tool: it prints the
    command that is to be run, executes it, and if quits with the command's
    output if the return code is non-zero.
    """
    print cmd
    exit_code, output = commands.getstatusoutput(cmd)
    if exit_code != 0:
        sys.exit(output)

# Order of these options matters because they are in the order they occur in
# the output files generated by our `Makefile`. Ideally the filename pattern
# would be extracted and parsed when this script is run, but this process will
# be omitted due to time constraints on the project.
fields = ['funcs', 'cc', 'opt', 'size']

parser = argparse.ArgumentParser(description='Plot the timing of a function')
parser.add_argument('-f', '--funcs', type=strs, default=glob_match("src/time_*.c"), help="matrix function to time")
parser.add_argument('-c', '--cc', type=strs, default=['cc'], help="C compiler")
parser.add_argument('-o', '--opt', type=ints, default=[0], help="C compiler optimization")
parser.add_argument('-n', '--num_points', type=int, default=100, help="number of graph points")
parser.add_argument('-s', '--size', type=ints, default=[100], help="matrix width and height")

args = vars(parser.parse_args())

impls = glob_match("src/matrix_*.c")

make_fmt = lambda pairs: ' '.join("%s=%s" % pair for pair in pairs)

# FIXME `css` is a list of `(f, v)` pairs, where `f` is a field name and `v` is
# the possible values for the field. The list is sorted in descending order on
# the size of `v`, which makes some graphs look nicer (graphs where the number
# of columns is equal to the size of the largest `v`). This is a very hacky
# implementation and should be replaced as soon as it is feasible.
css = sorted([(f, args[f]) for f in fields], key=lambda p: len(p[1]), reverse=True)

subplots = []
cs = list(comb.combs(map(lambda x: x[1], css)))
for i in xrange(len(cs)):
    c = dict(zip(map(lambda f: f[0], css), map(str, cs[i])))
    fname = ("build/dat/time_" + c['funcs'] + '_%s_'
            + '_'.join(c[f] for f in fields if f != 'funcs')
            + '_' + str(args['num_points']) + '.txt')

    lines = {}
    for impl in impls:
        env_vars = [('IMPL', impl)] + [(f.upper(), c[f]) for f in fields if f != 'funcs'] + [('NUM_POINTS', args['num_points'])]
        run("%s make %s" % (' '.join("%s=%s" % v for v in env_vars), fname % impl))
        points = []
        with open(fname % impl) as f:
            for _ in xrange(int(f.readline()[:-1])):
                x, y = map(float, f.readline().split())
                points.append({"x": x, "y": y})
        lines[impl] = {
            'colour': None,
            'points': points
        }

    subplots.append({
        'title': make_fmt((f.upper(), c[f]) for f in fields if len(args[f]) != 1),
        'lines': lines
    })

outf = "build/dat/time_" + '_'.join(','.join(map(str, args[name])) for name in fields) + ".json"
with open(outf, 'w') as f:
    json.dump({
            'title': make_fmt((f.upper(), args[f][0]) for f in fields if len(args[f]) == 1),
            'x-title': "Density (%)",
            'y-title': "Time (ns)",
            'share-x': True,
            'share-y': False,
            'share-lines': True,
            'subplots': subplots
    }, f)
